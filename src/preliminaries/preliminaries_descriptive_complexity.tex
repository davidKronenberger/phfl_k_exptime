%%
%% Author: Davidov
%% 27.04.2018
%%

\subsection{Descriptive Complexity}\label{subsec:descriptiveComplexity}

One way to describe complexity classes is with the help of \textit{Turing Machines}~\cite{hopcroft1994einfuehrung}.

\begin{definition}
    The seven-tuple $M = (Q, \Sigma, \Gamma, \delta, q_0, \Box, F, R)$ is called a \emph{Deterministic Turing Machine}
    ($\mathit{DTM}$),
    where
    \begin{compactitem}
        \item $Q$ is the finite set of states,
        \item $\Sigma$ is the input alphabet,
        \item $\Gamma$ is the working alphabet with $\Sigma \subset \Gamma$,
        \item $\delta : (Q \setminus (F \cup R)) \times \Gamma \rightarrow Q \times \Gamma \times \{L, R, N\}$ is the
        transition function,
        \item $q_0 \in Q$ is the initial state,
        \item $\Box \in \Gamma \setminus \Sigma$ is the blank symbol,
        \item $F \subseteq Q$ is the set of accepting states and
        \item $R \subseteq Q$ is the set of rejecting states.
    \end{compactitem}
\end{definition}

Configurations are snapshots of $\mathit{DTM}$s working on an input word. This includes the working tape, the current
state and the current position of the reading head. Formally, $C_i^M(w) = \Gamma^m \cdot Q \cdot (\Gamma^n | \Box)$
is called the $i$-th configuration of a $\mathit{DTM}$ $M = (Q, \Sigma, \Gamma, \delta, q_0, \Box, F)$ for input word
$w \in \Sigma^*$, where $m \geq 0$ and $n \geq 1$. In addition, $\Gamma^m$ represents the word of all symbols left
from the reading head position to the last symbol that is unequal to the blank symbol. $\Gamma^n$ represents the word
of all symbols right of the reading head position to the last symbol that is unequal to the blank symbol. If there
are no symbols unequal to the blank symbol right of the reading head position, the blank symbol $\Box$ of $M$ is used
instead of $\Gamma^n$.

\begin{definition}
    Let $C_i^M(w) = \gamma_1^i\dots\gamma_{m_i}^i{q_i}{\gamma_1^i}'\dots{\gamma_{n_i}^i}'$, $C_j^M(w) =
    \gamma_1^j\dots\gamma_{m_j}^j{q_j}{\gamma_1^j}'\dots{\gamma_{n_j}^j}'$ two configurations of a $\mathit{DTM}$ $M = (Q, \Sigma,
    \Gamma,
    \delta, q_0, \Box, F)$ for input word $w \in \Sigma^*$ with $i \neq j$. $C_j^M(w)$ is the next configuration
    of $C_i^M(w)$ written as $C_i^M(w) \rightarrow_M C_j^M(w)$ iff $j = i + 1$ and
    \begin{compactitem}
        \item $m_j = m_i - 1$, $\gamma_1^j = \gamma_1^i, \dots \gamma_{m_j}^j = \gamma_{m_j}^i$, $n_j = n_i + 1$,
        ${\gamma_1^j}' = \gamma_{m_i}^i, {\gamma_2^j}' = a, {\gamma_3^j}' = {\gamma_2^i}' \dots {\gamma_{n_j}^j}' =
        {\gamma_{{n_j}- 1}^i}'$ and $\delta(q_i, {\gamma_1^i}') = (q_j, a, L)$ or
        \item $m_j = m_i + 1$, $\gamma_1^j = \gamma_1^i, \dots \gamma_{m_j-1}^j = \gamma_{m_j-1}^i, \gamma_{m_j}^j
        = a$, $n_j = n_i - 1$, ${\gamma_1^j}' = {\gamma_2^i}', \dots {\gamma_{n_j}^j}' = {\gamma_{{n_j}+1}^i}'$ and
$\delta (q_i, {\gamma_1^i}') = (q_j, a, R)$ or
        \item $m_j = m_i$, $\gamma_1^j = \gamma_1^i, \dots \gamma_{m_j}^j = \gamma_{m_j}^i$, $n_j = n_i$, ${\gamma_1^j}'
= a, {\gamma_2^j}' = {\gamma_2^i}' \dots {\gamma_{n_j}^j}' = {\gamma_{n_j}^i}'$ and $\delta
        (q_i, {\gamma_1^i}') = (q_j, a, N)$.
    \end{compactitem}
    $C_i^M(w) \rightarrow_M C_j^M(w)$ is called a \emph{transition} of $M$ on $w$.
\end{definition}

The start configuration for an input word $w$ of a $\mathit{DTM}$ $M$ is $C_0^M(w) = q_0w$, where $q_0$ is the
initial state of $M$. A run of $\mathit{DTM}$ $M$ on input word $w$ is a sequence of transitions, $C_0^M(w)
\rightarrow_M C_1^M(w) \rightarrow_M C_2^M(w) \rightarrow_M \dots \rightarrow_M C_n^M(w)$, where $C_n^M(w)$ includes
either an accepting or rejecting state. A run is accepting if there is a $n \in \mathcal{N}$ such that $C_0^M(w)
\rightarrow_M C_1^M(w) \rightarrow_M \dots \rightarrow_M C_n^M(w)$ and $C_n^M(w)$ contains an accepting state of $M$.

Remark, that it is possible to define $\mathit{DTM}$s that does not accept or reject any input word. For example, let
$M = (\{q_0\}, \{a\}, \{a, \Box\}, \delta, \emptyset, \emptyset)$, where $\delta(q_0, x) = (q_0, x, N)$ with $x \in
\{a, \Box\}$. $M$ is a DTM where any calculation of an input word $w$ looks as follows $q_0w \rightarrow_M q_0w
\rightarrow_M \dots$. It never reaches an accepting or rejecting state. In this thesis, we are only interested in
$\mathit{DTM}$s that reaches an accepting or rejecting state in finite time on any input word.

Known from computational complexity theory~\cite{papadimitriou1994complexity}, the time and space classes
can be defined by functions. These functions have as input a natural number that represents the length of an input
word of a $\mathit{DTM}$. In case of time classes the output of the functions depends on the number of configuration
steps. In case of space classes the output is based on the longest transition.

\begin{definition}
    Let $M$ be a $\mathit{DTM}$. $\mathit{TIME}(n):= max(\mathit{STEPS}(w)\mid |w| = n)$, where $\mathit{STEPS}(w)$
    is the number of transitions while $M$ computes $w$. $\mathit{SPACE}(n) := max(\mathit{STORAGE}(w)\mid |w| = n)$,
    where $\mathit{STORAGE}(w) := max(length(C_i^M)\mid i\in\{1, \dots m\})$ is the longest configuration while $M$
    computes $w$ and $C_0^M(w) \rightarrow_M C_1^M(w) \rightarrow_M \dots \rightarrow_M C_m^M(w)$ is a run of $M$ on
    $w$.
\end{definition}

Now, it is possible to group the $\mathit{DTM}$s by functions. Those groups are our computational complexity classes.
In this thesis we are interested in exponential time classes and exponential space classes.

\begin{definition}
    Let $f: \mathbb{N} \rightarrow \mathbb{N}$ be a polynomial function, then $\emph{exp}: \mathbb{N} \times \mathbb{N}
    \rightarrow \mathbb{N}$ is a function defined inductive as follows:
    \begin{compactitem}
        \item $exp(0, f(n)) = f(n)$,
        \item $exp(i, f(n)) = 2^{exp(i - 1, f(n))}$ for $i \geq 1$.
    \end{compactitem}
\end{definition}

With the help of function $exp$, we are now able to define the complexity classes $k$-EXPTIME and $k$-EXPSPACE for
all $k \geq 1$.

\begin{definition}
    Let $k \in \mathbb{N} \setminus \{0\}$ and $f: \mathbb{N} \rightarrow \mathbb{N}$ be a polynomial function then
    $k$-EXPTIME $=$ $\mathit{TIME}$($exp(k, f(n))$) and $k$-EXPSPACE $= \mathit{SPACE}(exp(k, f(n)))$.
\end{definition}

Remark that $\mathit{TIME}$ is the maximal number of transitions and $\mathit{SPACE}$ the biggest configuration of a
$\mathit{DTM}$ while computing a word.

From Definition~\ref{definition:bisimulationInvariant}, Definition~\ref{definition:queryBelongsToComplexityClass}
and the complexity classes $k$-EXPTIME and $k$-EXPSPACE follow the queries that we want to investigate.

\begin{definition}
    \label{definition:kExptimekExpspace}
    \exptime{$k$} are the bisimulation invariant queries that belong to complexity class $k$-EXPTIME and
    \expspace{$k$} are the bisimulation invariant queries that belong to complexity class $k$-EXSPACE, where $k \geq 1$.
\end{definition}

The main aim of \emph{descriptive complexity} is to describe the complexity classes known from
computational complexity theory with logics. While computational complexity theory distinguishes time and space
classes, descriptive complexity theory characterizes classes with logical resources instead of a reference to
automaton models or space and time bounds.

The first known result in the area of descriptive complexity comes from Fagin. In 1974 he showed that the complexity
class NP coincides with $\exists SO$~\cite{fagin1974generalized}, the existential fragment of second-order logic.

In the next chapter we introduce the polyadic higher order fixed point logic and a restriction called tail-recursive
devised by Lange and Lozes in~\cite{lange2014capturing}. We want to compare the in
Definition~\ref{definition:kExptimekExpspace} presented queries with these logics to make a further contribution in
the theory of descriptive complexity.