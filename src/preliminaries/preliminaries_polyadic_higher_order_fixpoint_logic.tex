
%%
%% Author: Davidov
%% 16.05.2018
%%

\section{Polyadic Higher Order Fixpoint Logic}\label{sec:polyadichigherorderfixpointlogic}

In this section, we present a logic with name Polyadic Higher Order Fixpoint Logic, abbreviated with PHFL, that was
introduced by M. Lange and E. Lozes in~\cite{lange2014capturing}. It is defined over LTS (see
Definition~\ref{definition:lts}) and extends the polyadic modal $\mu$-calculus~\cite{otto1999bisimulation} with
higher order fixpoints like M. Viswanathan and R. Viswanathan it did with monadic case of modal
$\mu$-calculus~\cite{kozen1983results} in~\cite{viswanathan2004higher}. The logic of M. Viswanathan and R
.Viswanathan with name higher order fixed point logic is a combination of propositional logic, modality operators and
a simply typed $\lambda$-calculus with fixed point operators. The higher order cases of PHFL and a restriction called
tail-recursive for this higher order cases we are interested to compare with the in
Chapter~\ref{sec:descriptiveComplexity} introduced complexity classes \exptime{$k$} and \expspace{$k$}.

\subsection{PHFL Types}\label{subsec:phflTypes}

Before defining formulas of PHFL we need to introduce the PHFL types. These definitions are guided
by~\cite{viswanathan2004higher} and~\cite{lange2014capturing}.

\begin{definition}
    \emph{PHFL types} are given by the grammar
    \[\sigma, \tau \Coloneqq \bullet \mid \sigma^v \rightarrow \tau,\]
    where $v$ is called \textit{variance}. The \emph{variances} of PHFL are defined by the grammar
    \[v \Coloneqq + \mid - \mid 0.\]
\end{definition}

All types will be interpreted as a partially ordered sets. Partial orders are relations that are reflexive, transitive
and antisymmetric. Let $\mathcal{A} = (A, \leq_A)$ and $\mathcal{B} = (B, \leq_B)$ be two partial orders then
$\mathcal{A} \rightarrow \mathcal{B}$ is the partial order of monotone functions ordered pointwise, i.e.
\[\mathcal{A} \rightarrow \mathcal{B} = \{f\colon A\rightarrow B \mid \forall x,y \in A.\,x\leq_A y\Rightarrow f(x)
\leq_B f(y)\}\]
and the ordering relation is given by
\[f \leq_{\mathcal{A}\rightarrow\mathcal{B}} g\text{ iff } \forall x\in \mathcal{A}.\,f(x) \leq_{\mathcal{B}} g(x)\].

\begin{definition}
    Let $\mathcal{T} = (Q, \Sigma, P, \Delta, v)$ be a LTS, then $\mathcal{T}\llbracket\tau\rrbracket$ the semantics
    of type $\tau$ is defined by $\tau$ as follows:
        \[\mathcal{T}\llbracket\tau\rrbracket=
        \begin{cases}
            (\mathcal{P}(Q^d), \subseteq),  & \text{if }\tau = \bullet\\
            ((\mathcal{T}\llbracket\sigma_1\rrbracket)^v \rightarrow \mathcal{T}\llbracket\sigma_2\rrbracket, \leq_{
            (\mathcal{T}\llbracket\sigma_1\rrbracket)^v \rightarrow \mathcal{T}\llbracket\sigma_2\rrbracket}), &
            \text{if }\tau = \sigma_1^v\rightarrow \sigma_2,
        \end{cases}\]
    where for any partial order $\mathcal{A} = (A, \leq_A)$, $\mathcal{A}^v = (A, \leq_A^v)$ is a partial order
    with $\leq_A^+ = \leq_A$, $\leq_A^- = \{(a, b) \mid (b, a) \in \leq_A\}$ and $\leq_A^0 = \leq_A^+ \cap \leq_A^-$.
\end{definition}

The partial orders $\mathcal{T}\llbracket\tau\rrbracket$ for any PHFL type $\tau$ are complete lattices. That means we
have meets and joins, denoted by $\sqcap_{\mathcal{T}\llbracket\tau\rrbracket}$ and
$\sqcup_{\mathcal{T}\llbracket\tau\rrbracket}$, and least and greatest elements, denoted by
$\bot_{\mathcal{T}\llbracket\tau\rrbracket}$ and $\top_{\mathcal{T}\llbracket\tau\rrbracket}$ for any subset of
$\mathcal{T}\llbracket\tau\rrbracket$. This ensures that the least and greatest fixpoint over all monotone PHFL types
exist~\cite{tarski1955lattice}. See Chapter~\ref{subsec:hoPlusLfp} for further information about fixpoints.

\begin{definition}
    The \emph{maximal arity} $ma(\tau)$ and the \emph{order} $ord(\tau)$ of a PHFL type $\tau$ are defined
    inductively on
    $\tau$ as follows:
\[ma(\tau)=
\begin{cases}
    1, & \text{if }\tau = \bullet\\
    max(\{n\} \cup \{ma(\tau_i)\mid1,\dots,n\}), &
    \text{if }\tau = \tau_1\rightarrow\dots\rightarrow\tau_n\rightarrow\bullet
\end{cases}\]
\[ord(\tau)=
\begin{cases}
    0, & \text{if }\tau = \bullet\\
    max(\{1 + ord(\sigma_1), ord(\sigma_2)\}), & \text{if }\tau = \sigma_1 \rightarrow \sigma_2
\end{cases}\]
\end{definition}

Next, we want to define the syntax of PHFL formulas.

\subsection{PHFL Syntax}\label{subsec:phflSyntax}

\begin{figure}
    \caption{Derivation Rules for PHFL formulas.}
    \label{figure:phfl-typing-rules}
    \begin{mathpar}
        \Gamma \vdash \top \colon \bullet \and
        \Gamma \vdash p_i \colon \bullet \and
        \inferrule{\Gamma \vdash \Phi \colon \bullet}{\Gamma \vdash \langle a \rangle_i \Phi \colon \bullet} \and
        \inferrule{\Gamma \vdash \Phi \colon \bullet}{\Gamma \vdash \{\emph{i} \leftarrow \emph{j}\}\Phi \colon
        \bullet} \and
        \inferrule{\Gamma^-\vdash\Phi\colon \tau}{\Gamma \vdash \neg \Phi \colon \tau} \and
        \inferrule{\Gamma\vdash\Phi \colon \tau \\ \Gamma\vdash\Psi\colon \tau}{\Gamma \vdash \Phi \vee
        \Psi \colon  \tau} \and
        \inferrule{v \in \{+, 0\} }{\Gamma, X^v \colon\tau \vdash X\colon\tau} \and
        \inferrule{\Gamma,X^v\colon\sigma\vdash \Phi\colon\tau}{\Gamma\vdash \lambda (X^v \colon \tau)
        .\Phi\colon\sigma^v\rightarrow\tau} \and
        \inferrule{\Gamma,X^+ \colon \tau \vdash \Phi\colon\tau}{\Gamma \vdash \mu (X \colon\tau). \Phi\colon\tau} \and
        \inferrule{\Gamma\vdash \Phi\colon\sigma^+ \rightarrow \tau \\ \Gamma\vdash\Psi\colon\sigma}{\Gamma \vdash
        \Phi\Psi \colon \tau} \and
        \inferrule{\Gamma\vdash \Phi\colon\sigma^- \rightarrow \tau \\ \Gamma^-\vdash\Psi\colon\sigma}{\Gamma \vdash
        \Phi\Psi \colon \tau} \and
        \inferrule{\Gamma\vdash \Phi\colon\sigma^0 \rightarrow \tau \\ \Gamma \vdash \Psi\colon\sigma \\ \Gamma^-
        \vdash\Psi\colon\sigma}{\Gamma \vdash \Phi\Psi \colon \tau} \and
    \end{mathpar}
\end{figure}

\begin{definition}
    Let $P$ a set of propositions, $\Sigma$ a set of actions and $\mathcal{V} = \{X_1, \dots, X_n\}$ a finite set
    of variables, then
    \emph{$d$-adic PHFL formulas} $\Phi, \Psi,\dots$ are defined by the grammar
    \begin{align*}
        \Phi,\Psi\Coloneqq&\top \mid p_i \mid \Phi \vee \Psi \mid \neg \Phi \mid \langle a \rangle_i \Phi \mid
        \{\emph{i}
        \leftarrow \emph{j}\} \Phi \mid X_1 \mid \lambda (X_1^v\colon\tau).\Phi \mid \Phi \Psi\mid  \\
        &\mu (X_1\colon\tau).\Phi
    \end{align*}
    where
    \begin{compactitem}
        \item $\emph{i} = (i_1,\dots, i_n)$, $\emph{j} = (j_1,\dots,j_n)$, $i, n, i_1,\dots,i_n, j_1, \dots j_n \in
        \{1, \dots, d\}$,
        \item $v$ is an arbitrary variance,
        \item $\tau$ is an arbitrary type,
        \item $p \in P$ is an arbitrary property and
        \item $a \in \Sigma$ is an arbitrary action.
    \end{compactitem}
\end{definition}

For convenience, we use some other further standard notations like $\Phi \wedge \Psi$, $[a]_i\Phi$, $\nu
X \colon \tau.\Phi$ or $\Phi \Leftrightarrow \Psi$. Note, that this logic is defined over LTS. The formulas are
often interpreted as a game played by two players moving pebbles along the transitions of an LTS. The two players
are often called Prover and Refuter. So, $p_i$ can be interpreted as, the position of the $i$-th pebble fulfills
property $p$. $\langle a \rangle_i \Phi$ means, Prover has to move the $i$-th pebble along an $a$-transition and
check if there holds $\Phi$. With the formula $\{\emph{i}\leftarrow\emph{j}\} \Phi$ is mentioned, that all pebbles
from tuple $\emph{j}$ are moved from Prover to the tuple $\emph{i}$ and after this $\Phi$ have to be fulfilled. It is
important that $\emph{i}$ and $\emph{j}$ have the same size that the movements of the pebbles are clear. In case of
negation these movements have do be made from the Refuter. $\lambda (X^v\colon\tau).\Phi$ is interpreted as a
function that expects arguments of $\mathcal{T}\llbracket\tau^v\rrbracket$. We can see, that the formulas can also
have types. For this, we have ensure that a formula is well-typed.

\begin{definition}
    Let $X_1, \dots, X_n$ variables, $\Phi$ a PHFL formula, $v_1, \dots, v_n$ variances and $\tau, \tau_1, \dots,
    \tau_n$ types, then $\Gamma = X_1^{v_1}\colon \tau_1, \dots X_n^{v_n} \colon \tau_n$ is
    called a \emph{type environment} and $\Gamma \vdash \Phi\colon\tau$
    is called a \emph{type judgement}. Let $\Gamma^- = X_1^{v_1^-}\colon \tau_1, \dots
    X_n^{v_n^-} \colon \tau_n$ be a type environment then $\Gamma^- = X_1^{v_1^-}\colon \tau_1, \dots
    X_n^{v_n^-} \colon \tau_n$, where $-^- = +$, $+^- = -$ and $0^- = 0$.
\end{definition}

A type judgment is called \textit{derivable} if a derivation tree exists respectively to the rules of
Figure~\ref{figure:phfl-typing-rules}. This type system ensures that we do not create senseless formulas like
$\langle a \rangle_i p_j$ set on $p_k$. Furthermore, it guarantees monotonicity by control negations. A formula
$\Phi$ is called \textit{well-typed} if the type judgement $\emptyset \vdash \Phi:\tau$ is derivable for some type
$\tau$. Note, that we are here only interested in well-typed formulas. For those formulas where also the variable
types are obvious, we omit the type on the variables.

\subsection{PHFL Semantics}\label{subsec:phflSemantics}

To define the semantics of PHFL formulas we need mapping $\eta$ that associates each variable to an element of its
type semantics, i.e. $\eta(X) \in \mathcal{T}\llbracket\tau\rrbracket$ for $X$ of type $\tau$. Let $\Phi$ be a
well-typed formula of type $\tau$ and $\eta$ a variable mapping, then the semantics $\llbracket\Gamma \vdash \Phi
\colon \tau \rrbracket(\eta)$ is defined inductively on $\Phi$ which maps to an element of
$\mathcal{T}\llbracket\tau\rrbracket$ as explained in Figure~\ref{figure:phfl-semantics}.
Note, that $\eta[X \mapsto \mathcal{X}]$ is a mapping $\eta'$ that is equal to $\eta$ but $\eta'(X) = \mathcal{X}$ and
with $\emph{q}, \emph{q'} \in Q^d$, $\emph{q} \overset{a, i}{\rightarrow} \emph{q'}$ stands for $q_i
\overset{a}{\rightarrow} {q_i}'$ and for all $j \neq i$ holds $q_j = {q_j}'$.

\begin{figure}
    \caption{Semantics of PHFL formulas.}
    \label{figure:phfl-semantics}
    \begin{align*}
        \llbracket \Gamma \vdash \top \colon \bullet \rrbracket(\eta) =\,& Q^d\\
        \llbracket \Gamma \vdash p_i \colon \bullet \rrbracket(\eta) =\,& \{(q_1, \dots, q_d) \in Q^d \mid p \in \nu
        (q_i)\}\\
        \llbracket \Gamma \vdash \langle a \rangle_i \Phi \colon \bullet \rrbracket(\eta) =\,& \{\emph{q} \in Q^d \mid
        \exists \emph{q'} \in \llbracket \Gamma \vdash \Phi \colon \bullet \rrbracket.\,\emph{q}
        \overset{a, i}{\rightarrow} \emph{q'}\}\\
        \llbracket \Gamma \vdash \Phi \vee \Psi \colon \tau \rrbracket(\eta) =\,& \llbracket \Gamma \vdash \Phi
        \colon \tau \rrbracket (\eta) \sqcup_\tau \llbracket \Gamma \vdash \Psi \colon \tau \rrbracket (\eta)\\
        \llbracket \Gamma \vdash \neg \Phi \colon \tau \rrbracket(\eta) =\,& Q^d \setminus \llbracket \Gamma^- \vdash \Phi
        \colon \tau \rrbracket (\eta)\\
        \llbracket \Gamma \vdash \{\emph{i} \leftarrow \emph{j}\} \Phi \colon \bullet \rrbracket(\eta) =\,&
        \{\{\emph{i} \leftarrow \emph{j}\}(\emph{q}) \mid \emph{q} \in \llbracket \Gamma \vdash \Phi \colon \bullet
        \rrbracket (\eta)\}\\
        \llbracket \Gamma, X \colon \tau \vdash X \colon \tau \rrbracket(\eta) =\,& \eta(X)\\
        \llbracket \Gamma \vdash \mu (X \colon \tau).\,\Phi \colon \tau \rrbracket(\eta) =\,&
        \sqcap_{\mathcal{T}\llbracket\tau\rrbracket} \{\mathcal{X} \in \mathcal{T}\llbracket \tau \rrbracket \mid \\
        &\llbracket \Gamma, X^+ \colon \tau \vdash \Phi \colon \tau \rrbracket(\eta[X \mapsto \mathcal{X}])
        \leq_{\mathcal{T}\llbracket \tau \rrbracket} \mathcal{X}\}\\
        %\llbracket         \Gamma
 %       \vdash
  %      \lambda X^+ \colon \tau.\Phi \colon \tau \rrbracket (\eta)\\
        \llbracket \Gamma \vdash \lambda (X^v \colon \sigma).\,\Phi \colon \sigma^v \rightarrow \tau \rrbracket
        (\eta) =\,& F \in \mathcal{T}\llbracket \sigma^v \rightarrow \tau \rrbracket \text{ s.t. } \forall
        \mathcal{X} \in \mathcal{T}\llbracket \sigma \rrbracket.\, \\
        &F(\mathcal{X}) = \llbracket \Gamma, X^v
        \colon \sigma \vdash \Phi \colon \tau \rrbracket (\eta[X \mapsto \mathcal{X}])\\
        \llbracket \Gamma \vdash \Phi \Psi \colon \tau \rrbracket(\eta) =\,& \llbracket \Gamma \vdash \Phi \colon \sigma
        ^v \rightarrow \tau \rrbracket (\eta)(\llbracket \Gamma \vdash \Psi \colon \sigma \rrbracket (\eta)))
    \end{align*}
\end{figure}

In this thesis we are interested in PHFL formulas that have a specific order. For this, a formula $\Phi$ have order $k$
if $k = max(\{ord(\tau)\mid \Psi \colon \tau$ \textit{is a subformula of} $\Phi\})$. The set of formulas that have
order at most $k$ is denoted by PHFL$^k$.

\begin{example}{\cite{lange2014capturing}}
    \label{example:phfl}
    The following formula $\Phi$ describes trace equivalence of two states in a LTS i.e. it denotes those pairs $
    (q_1, q_2)$ for which $q_1$ has the same traces like $q_2$ and vice versa.
    \[\Phi \Coloneqq (\mu F. \lambda X, Y. X \Leftrightarrow Y \wedge \underset{a \in \Sigma}{\bigwedge} F \langle a
    \rangle_1 X \langle a \rangle_2 Y)\top \top\]
\end{example}

\subsection{Tail-Recursive PHFL}\label{subsec:tail-recursivePhfl}

Next, we want to define a fragment of PHFL formulas. This fragment is called tail-recursive and ensures that
some combinations of subformulas don't appear in an PHFL formula. For this, let the logical connective
$\wedge$ and the modality operators $[a]_i$ be further primitives of PHFL formula syntax. Intuitively, tail-recursive
PHFL formulas are PHFL formulas, where all least fixpoint variables do not occur freely under the operators
$\wedge$, $\neg$ and $[a]_i$, nor in $\Psi$ of formula $\Phi\Psi$.

\begin{definition}
    A closed PHFL formula $\Phi$ is called \emph{tail-recursive} if $\emptyset \vdash tail(\Phi, \emptyset)$ is
    derivable via the rules in Figure~\ref{figure:phfl-tail-recursive}.
\end{definition}

\begin{figure}
    \caption{Derivation Rules for PHFL formulas that shall be tail-recursive.}
    \label{figure:phfl-tail-recursive}
    \begin{mathpar}
        \bar{Y} \vdash tail(p_i, \bar{X}) \and
        \inferrule{X \in \bar{X} \cup \bar{Y}}{\bar{Y} \vdash tail(X, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \emptyset)}{\bar{Y} \vdash tail(\neg \Phi, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \bar{X})}{\bar{Y} \vdash tail(\{\emph{i} \leftarrow \emph{j}\} \Phi,
        \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \bar{X}) \\ \bar{Y} \vdash tail(\Psi, \bar{X})}{\bar{Y} \vdash tail
        (\Phi \vee \Psi, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \bar{X})}{\bar{Y} \vdash tail(\langle a \rangle_i \Phi, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \emptyset)}{\bar{Y} \vdash tail([a]_i \Phi, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \emptyset) \\ \bar{Y} \vdash tail(\Psi, \bar{X})}{\bar{Y} \vdash tail
        (\Phi \wedge \Psi, \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \bar{X}) \\ \bar{Y} \vdash tail(\Psi, \emptyset)}{\bar{Y} \vdash tail
        (\Phi \Psi, \bar{X})} \and
        \inferrule{\bar{Y} \cup \{Z\} \vdash tail(\Phi, \bar{X})}{\bar{Y} \vdash tail(\lambda Z^v \colon \tau . \Phi,
        \bar{X})} \and
        \inferrule{\bar{Y} \vdash tail(\Phi, \bar{X} \cup \{Z\})}{\bar{Y} \vdash tail(\mu Z \colon \tau . \Phi,
        \bar{X})}
    \end{mathpar}
\end{figure}

The set of all tail-recursive PHFL formulas that have order at most $k$ is denoted by PHFL$^k_{tail}$.

\begin{example}{\cite{lange2014capturing}}
    Looking at Figure~\ref{figure:phfl-tail-recursive}, we can see, that $\Phi_1 = \mu X.[a]_1 X$ is not tail
    recursive, because $X$ occurs under $[a]_1$. Also $\Phi_2 = \mu F .\lambda X. (F X) \wedge (F(F X))$
    isn't tail-recursive because $F$ occurs on the left side of the logical operator $\wedge$. The second reason, why
    $\Phi_2$ isn't tail-recursive is because $F$ also occurs in $F X$ of subformula $F (F X)$. An example of a
    formula that is tail-recursive is given by:
    \[(\nu F. \lambda X. (F \langle a \rangle_1 X) \vee (X \wedge \langle a \rangle_2 (F X)) (\mu Y.Y))\]
\end{example}